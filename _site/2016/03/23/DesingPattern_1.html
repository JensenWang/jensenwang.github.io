<!DOCTYPE html> <html> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" /> <!--[if lte IE 9]><meta http-equiv="refresh" content="0;url=/ie.html"><![endif]--> <title>Java开发中常见的23种设计模式(一)</title> <meta name="description" content="概论设计模式（Design pattern） 一套被反复使用，多数人知晓的，经过分类编目的，代码设计经验的总结。使用设计模式市委了可重用代码，让代码更容易被他人理解，保证代码可靠性。"> <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,400italic,600|Droid+Sans+Mono' rel='stylesheet' type='text/css'> <link rel="stylesheet" href="/css/main.css"> <link rel="canonical" href="http://jensenwang.github.io/2016/03/23/DesingPattern_1.html"> <link rel="alternate" type="application/rss+xml" title="JensenWang" href="http://jensenwang.github.io/feed.xml" /> <link rel="shortcut icon" type="image/x-icon" href="/assets/img/avatar.jpg" media="screen" /> <script src="/assets/js/prefixfree.js"></script> </head> <body> <aside id="sidebar"> <div id="sidebar-left"> <a id="sidebar-avatar" href="/"> <img id="sidebar-avatar-img" alt="" src="/assets/img/avatar.jpg"/> </a> <div id="sidebar-social"> <a href="/feed.xml" class="sidebar-social-icon feed"></a> <a href="mailto:blankinter@163.com" class="sidebar-social-icon email"></a> <a href="https://github.com/jensenwang" class="sidebar-social-icon github" target="_blank"></a> </div> <ul id="sidebar-tags"> <li class="sidebar-tag active" data-filter="all">全部文章</li> <li class="sidebar-tag" data-filter="Java">Java</li> </ul> </div> <div id="sidebar-right"> <div id="search-box"> <input id="search-input" type="text" placeholder="Search" /> </div> <nav id="toc"> <a class="toc-link" data-tags="Java" href="/2016/04/08/DesingPattern_2.html"> Java开发中常见的23种设计模式(二) </a> <a class="toc-link" data-tags="Java" href="/2016/03/23/DesingPattern_1.html"> Java开发中常见的23种设计模式(一) </a> <a class="toc-link" data-tags="Java" href="/2016/02/29/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html"> Java异常处理 </a> <a class="toc-link" data-tags="Java" href="/2016/01/24/Java%E5%9F%BA%E7%A1%80.html"> Java 基础 </a> </nav> </div> </aside> <main id="main"> <article class="post container"> <div class="post-meta"> <span class="post-meta-span date">2016 March 23</span> <span class="post-meta-span tag">Java</span> </div> <h1 class="post-title">Java开发中常见的23种设计模式(一)</h1> <h1 id="section">概论</h1> <p><em>设计模式（Design pattern）</em> 一套被反复使用，多数人知晓的，经过分类编目的，代码设计经验的总结。使用设计模式市委了可重用代码，让代码更容易被他人理解，保证代码可靠性。</p> <h2 id="section-1">设计模式的分类</h2> <p>总体来说设计模式分三大类：</p> <p><strong>创建型模式</strong></p> <p>共五种：工厂方法模式，抽象工厂模式，单例模式，构造者模式，原型模式</p> <p><strong>构造型模式</strong></p> <p>共7种：适配器模式，装饰器模式，代理模式，外观模式，桥接模式，组合模式，享元模式。</p> <p><strong>行为模式</strong></p> <p>共11种：策略模式，模板方法模式，观察者模式，迭代器模式，责任链模式，命令模式，备忘录模式，状态模式，访问者模式，中介者模式，解释器模式。 <img src="http://i3.piimg.com/6101f65132be0479.png" alt="" /></p> <h2 id="section-2">设计模式的六大原则</h2> <p><strong>1.开闭原则（Open Close Principle）</strong></p> <p>开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有代码，实现一个热插拔的效果。所以一句话概况就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用到接口和抽象类。</p> <p><strong>2.里氏代换原则（Liskov Substitution Principle）</strong></p> <p>里氏代换原则（Liskov Substitution Principle LSP）面向对象设计的基本原则之一。里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不收到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对”开-闭“原则的补充。实现”开-闭“原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则时对实现抽象化的具体规范。</p> <p><strong>3.依赖倒转原则（Dependence Inversion Principle）</strong></p> <p>这个时开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖具体。</p> <p><strong>4.接口隔离原则（Interface Segregation Principle）</strong></p> <p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这里我们看出，其实设计模式就是一个软件设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。</p> <p><strong>5.迪米特原则（最少知道原则）（Demeter Principle）</strong></p> <p>为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相互独立。</p> <p><strong>6.合成复用原则（Composite Reuse Principle）</strong></p> <p>原则时尽量使用合成/聚合的方式，而不是使用继承</p> <h2 id="section-3">工厂模式</h2> <p><strong>1.普通工厂模式</strong></p> <p>就是简单的一个工厂类，对实现了同一接口的一些类进行实例的创建。 <img src="http://i4.piimg.com/06456250dd0f82b9.png" alt="" /> 举例如下（我们举一个发送邮件和短信的例子） 首先，创建二者的共同接口：</p> <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Sender</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">send</span><span class="o">();</span>
<span class="o">}</span></code></pre></figure> <p>其次，创建实现类：</p> <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MailSender</span> <span class="kd">implements</span> <span class="n">Sender</span><span class="o">{</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="n">send</span><span class="o">(){</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"This is mail sender"</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span></code></pre></figure> <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SmsSender</span> <span class="kd">implements</span> <span class="n">Sender</span><span class="o">{</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="n">send</span><span class="o">()</span> <span class="o">{</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"This is sms sender"</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span></code></pre></figure> <p>最后，创建工厂类：</p> <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SenderFactory</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="n">Sender</span> <span class="n">prodece</span><span class="o">(</span><span class="n">String</span> <span class="n">type</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">type</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"mail"</span><span class="o">)){</span>
			<span class="k">return</span> <span class="k">new</span> <span class="n">MailSender</span><span class="o">();</span>
		<span class="o">}</span> <span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="s">"sms"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">type</span><span class="o">))</span> <span class="o">{</span>
			<span class="k">return</span> <span class="k">new</span> <span class="n">SmsSender</span><span class="o">();</span>
		<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
			<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"请输入正确的类型"</span><span class="o">);</span>
			<span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
		<span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span></code></pre></figure> <p>测试：</p> <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FactoryTest</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="n">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">SenderFactory</span> <span class="n">factory</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SenderFactory</span><span class="o">();</span>
		<span class="n">Sender</span> <span class="n">mailSender</span> <span class="o">=</span> <span class="n">factory</span><span class="o">.</span><span class="na">prodece</span><span class="o">(</span><span class="s">"mail"</span><span class="o">);</span>
		<span class="n">mailSender</span><span class="o">.</span><span class="na">send</span><span class="o">();</span>
		<span class="n">Sender</span> <span class="n">smsSender</span> <span class="o">=</span> <span class="n">factory</span><span class="o">.</span><span class="na">prodece</span><span class="o">(</span><span class="s">"sms"</span><span class="o">);</span>
		<span class="n">smsSender</span><span class="o">.</span><span class="na">send</span><span class="o">();</span>
	<span class="o">}</span>
<span class="o">}</span></code></pre></figure> <p><strong>2.多个工厂模式</strong></p> <p>多个工厂方法模式是对普通工厂方法模式的改进，在普通工厂模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂模式是提供多个工厂方法，分别创建对象。 <img src="http://i3.piimg.com/fe91f85d64d0329c.png" alt="" /> 将上面的方法修改，只需要修改SenderFactory类就行</p> <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SenderFactory</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">Sender</span> <span class="n">produceMail</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">MailSender</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">Sender</span> <span class="n">produceSms</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">SmsSender</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure> <p>测试如下：</p> <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FactoryTest</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="n">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">SenderFactory</span> <span class="n">factory</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SenderFactory</span><span class="o">();</span>
        <span class="n">Sender</span> <span class="n">mail</span> <span class="o">=</span> <span class="n">factory</span><span class="o">.</span><span class="na">produceMail</span><span class="o">();</span>
        <span class="n">mail</span><span class="o">.</span><span class="na">send</span><span class="o">();</span>
        <span class="n">Sender</span> <span class="n">sms</span> <span class="o">=</span> <span class="n">factory</span><span class="o">.</span><span class="na">produceSms</span><span class="o">();</span>
        <span class="n">sms</span><span class="o">.</span><span class="na">send</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure> <p><strong>3.静态工厂模式</strong></p> <p>将上面的多个工厂方法模式里面的方法设置为静态的，不需要创建实例，直接即可调用。</p> <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SenderFactory</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Sender</span> <span class="n">produceMail</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">MailSender</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Sender</span> <span class="n">produceSms</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">SmsSender</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure> <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FactoryTest</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="n">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Sender</span> <span class="n">sms</span> <span class="o">=</span> <span class="n">SenderFactory</span><span class="o">.</span><span class="na">produceSms</span><span class="o">();</span>
        <span class="n">sms</span><span class="o">.</span><span class="na">send</span><span class="o">();</span>
        <span class="n">Sender</span> <span class="n">mail</span> <span class="o">=</span> <span class="n">SenderFactory</span><span class="o">.</span><span class="na">produceMail</span><span class="o">();</span>
        <span class="n">mail</span><span class="o">.</span><span class="na">send</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure> <p><strong>总的来说</strong> 工厂模式适合：凡是出现了大量的产品需要来创建，并且有共同的接口时，可以通过使用工厂方法模式进行创建。在以上的三中模式中，第一种如果传入的字符串有误，不能正确的创建对象，第三种相对于第二种，不需要实例化工厂类，所以大多数情况下，，我们会选用第三种——静态工厂方法模式。</p> <h2 id="section-4">单例模式</h2> <p>单利对象（Singleton）是一种常用的设计模式。在Java应用中，单例对象能保证在一个JVM中，该对象只有一个实例存在。这样的模式有几个好处：</p> <ol> <li>某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销。</li> <li>省去了new操作符，降低了系统内存的使用频率，减轻GC压力。</li> <li>有些类比如交易所的核心交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。（比如一个军队出现了多个司令员同时指挥，肯定会乱成一团），所以只有使用单例模式，才能保证核心交易服务器控制整个流程。</li> </ol> <p>首先，我们写一个简单的单例类：</p> <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Singleton</span> <span class="o">{</span>
    <span class="cm">/* 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="n">Singleton</span> <span class="n">instance</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

    <span class="cm">/* 私有构造方法，防止被实例化 */</span>
    <span class="kd">private</span> <span class="n">Singleton</span><span class="o">()</span> <span class="o">{</span>

    <span class="o">}</span>

    <span class="cm">/* 静态工程方法，创建实例 */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Singleton</span> <span class="n">getInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Singleton</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/* 如果该对象被用于实例化，可以保证对象在序列化前后保持一致 */</span>
    <span class="kd">public</span> <span class="n">Object</span> <span class="n">reanResolve</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure> <p>这个类可以满足基本要求，但是这样毫无线程安全保护的类放到多线程的环境下，肯定会出问题。于是就可以对getInstance方法加上线程锁，如下：</p> <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="cm">/* 添加synchronized关键字锁住方法，保护线程安全 */</span>
<span class="kd">public</span> <span class="kd">synchronized</span> <span class="kd">static</span> <span class="n">Singleton</span> <span class="nf">getInstance</span><span class="p">(</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Singleton</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure> <p>但是synchronized是锁住对象，每次调用getInstance()都会锁住对象，但是实际上只有第一次创建对象对的时候要加锁，之后就不需要了，所以还是要优化：</p> <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="nf">Singleton</span><span class="p">(</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"实例化一次"</span><span class="o">);</span>
<span class="o">}</span>
<span class="cm">/* 此处用一个内部类来维护单例 */</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">SingletonFactory</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="n">Singleton</span> <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Singleton</span><span class="o">();</span>
<span class="o">}</span>
<span class="cm">/* 获取实例 */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="n">Singleton</span> <span class="nf">getInstance</span><span class="p">(</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">SingletonFactory</span><span class="o">.</span><span class="na">instance</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure> <p>实际情况是，单例模式使用内部类来维护单例的实现，JVM内部的机制能够保证当一个类被加载的时候，这个类的加载过程是线程互斥的。这样我们第一次调用getInstance()的时候，JVM能够保证instance只被创建一次，并且会把值赋给instance的内存初始化完毕。同时该方法只会在第一次调用的时候使用互斥机制，这样就解决了低性能问题。<em>但是</em>这样的话，如果在构造函数中抛出异常，实例将永久得不到创建，也会出错。也有人这样实现：我们只需要在创建类的时候进行同步，所以只需要将创建和getInstance()分开，单独为创建加synchronized关键字也是可以的，如下：</p> <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Singleton</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="n">Singleton</span> <span class="n">instance</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

    <span class="kd">private</span> <span class="n">Singleton</span><span class="o">(){</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"实例化一次。"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="n">syncInit</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">instance</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Singleton</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/* 将创建对象与getInstance分开，优化性能 */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Singleton</span> <span class="n">getInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">instance</span>  <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">syncInit</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure> <p><strong>问题：</strong> 能否采用静态方法，实现单例模式的效果，二者有什么不同？</p> <p>首先是可以使用静态方法实现单例模式的效果的，但是静态类不能实现接口。(从类的角度是可以的，但是那样就破坏了静态了。因为接口中不允许有static修饰的方法，所以即使实现了也是非静态的。)</p> <p>其次，单例类可以被延迟初始化，静态类一般在第一次加载是初始化。之所以延迟加载，是因为有些类比较庞大，所以延迟加载有助于提升性能。</p> <p>再次，单例类可以被继承，它的方法可以被覆写。但是静态类内部方法都是static，所以无法覆写。</p> <p>最后一点，单例类比较灵活，毕竟从实现上只是一个普通的Java类，只要满足单例的基本需求，你可以在里面随心所欲的实现一些其它功能，但是静态类不行。从上面这些概括中，基本可以看出二者的区别，但是，从另一方面讲，我们上面最后实现的那个单例模式，内部就是用一个静态类来实现的，所以，二者有很大的关联，只是我们考虑问题的层面不同罢了。</p> <h2 id="builder">建造者模式(Builder)</h2> <p>工厂模式提供的创建单个类的模式，而建造者模式（又叫生成器模式）则是将各种产品集中起来进行管理，用来创建复合对象，所谓复合对象就是指某个类具有不同的属性，其实建造者模式就是前面抽象工厂模式和最后的Test结合起来得到的。我们看一下代码:</p> <p>还是和前面一样，一个Sender接口，两个实现类MailSender和SmsSender。最后，建造者类如下：</p> <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Builder</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Sender</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Sender</span><span class="o">&gt;();</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">produceMailSender</span><span class="o">(</span><span class="kt">int</span> <span class="n">count</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">MailSender</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">produceSmsSender</span><span class="o">(</span><span class="kt">int</span> <span class="n">count</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">SmsSender</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure> <p>测试类：</p> <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="n">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Builder</span> <span class="n">builder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Builder</span><span class="o">();</span>
        <span class="n">builder</span><span class="o">.</span><span class="na">produceMailSender</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure> <p>从这点看出，建造者模式将很多功能集成到一个类里，这个类可以创造出比较复杂的东西。</p> <p>所以与工厂模式的区别就是：工厂模式关注的是创建单个的产品，而建造者模式则关注创建复合对象，多个部分。</p> <h2 id="prototype">原型模式（Prototype）</h2> <p>原型模式虽然是创建型模式，但是与工厂模式没有关系，从名字即可看出，该模式的思想就是将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象。在Java中，复制对象是通过clone()实现的，先创建一个原型类：</p> <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Prototype01</span> <span class="kd">implements</span> <span class="n">Cloneable</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="n">getAge</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">age</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">setAge</span><span class="o">(</span><span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="n">getName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">setName</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="n">Object</span> <span class="n">clone</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">CloneNotSupportedException</span> <span class="o">{</span>
        <span class="n">Prototype01</span> <span class="n">proto</span> <span class="o">=</span> <span class="o">(</span><span class="n">Prototype01</span><span class="o">)</span><span class="kd">super</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">proto</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="n">print</span><span class="o">(){</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Age:"</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">age</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Name:"</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span></code></pre></figure> <p>测试类：</p> <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="n">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Prototype01</span> <span class="n">pro1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Prototype01</span><span class="o">();</span>
        <span class="n">pro1</span><span class="o">.</span><span class="na">setAge</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
        <span class="n">pro1</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"ZhangSan"</span><span class="o">);</span>
        <span class="n">pro1</span><span class="o">.</span><span class="na">print</span><span class="o">();</span>
        <span class="n">Prototype01</span> <span class="n">pro2</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">pro2</span> <span class="o">=</span> <span class="o">(</span><span class="n">Prototype01</span><span class="o">)</span> <span class="n">pro1</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">CloneNotSupportedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// TODO Auto-generated catch block</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="n">pro2</span><span class="o">.</span><span class="na">print</span><span class="o">();</span>
    <span class="o">}</span>

<span class="o">}</span></code></pre></figure> <p>很简单，一个原型类，只需要实现Cloneable接口，覆写clone()方法，此处clone方法可以改成任意名字，因为Cloneable是个空接口，你可以任意定制实现类的名称，因为此处重点是super.clone()这句话，super.clone()调用的是Object的clone()方法，而在Object类中，clone()是native的。</p> <p><em>复制分浅复制和深复制，以上只是浅复制。</em> 浅复制：将一个对象复制后，基本数据类型的变量都会重建，而引用类型，指向的还是原来对象的指向</p> <p>深复制：将一个对象复制后，不论是基本数据类型还是引用类型，都是会重建的。</p> <p>简单的来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。</p> <p>深复制:</p> <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Prototype02</span> <span class="kd">implements</span> <span class="n">Cloneable</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">string</span><span class="o">;</span>
    <span class="cm">/* 深复制 */</span>
    <span class="kd">public</span> <span class="n">Object</span> <span class="n">deepClone</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">IOException</span><span class="o">,</span> <span class="n">ClassNotFoundException</span><span class="o">{</span>

        <span class="cm">/* 写入当前对象的二进制流 */</span>
        <span class="n">ByteArrayOutputStream</span> <span class="n">bos</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ByteArrayOutputStream</span><span class="o">();</span>
        <span class="n">ObjectOutputStream</span> <span class="n">oos</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ObjectOutputStream</span><span class="o">(</span><span class="n">bos</span><span class="o">);</span>
        <span class="n">oos</span><span class="o">.</span><span class="na">writeObject</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>

        <span class="cm">/* 读出二进制流产生的新对象 */</span>
        <span class="n">ByteArrayInputStream</span> <span class="n">bis</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ByteArrayInputStream</span><span class="o">(</span><span class="n">bos</span><span class="o">.</span><span class="na">toByteArray</span><span class="o">());</span>
        <span class="n">ObjectInputStream</span> <span class="n">ois</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ObjectInputStream</span><span class="o">(</span><span class="n">bis</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">ois</span><span class="o">.</span><span class="na">readObject</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="n">getString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">string</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">setString</span><span class="o">(</span><span class="n">String</span> <span class="n">string</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">string</span> <span class="o">=</span> <span class="n">string</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span></code></pre></figure> </article> <div class="post-share"> <div class="container"> <a href="https://twitter.com/share?url=http://jensenwang.github.io/2016/03/23/DesingPattern_1.html&text=Java开发中常见的23种设计模式(一)" target="_blank" class="post-share-icon twitter"></a> <a href="https://www.evernote.com/clip.action?url=http://jensenwang.github.io/2016/03/23/DesingPattern_1.html&title=Java开发中常见的23种设计模式(一)" target="_blank" class="post-share-icon evernote"></a> <a href="http://service.weibo.com/share/share.php?url=http://jensenwang.github.io/2016/03/23/DesingPattern_1.html&title=Java开发中常见的23种设计模式(一)" target="_blank" class="post-share-icon weibo"></a> </div> </div> <!-- 多说评论框 start --> <div style="width: 80% padding: 0 30px" class="ds-thread" data-thread-key=/2016/03/23/DesingPattern_1 data-title=Java开发中常见的23种设计模式(一) data-url=http://jensenwang.github.io//2016/03/23/DesingPattern_1.html></div> <!-- 多说评论框 end --> <!-- 多说公共JS代码 start (一个网页只需插入一次) --> <script type="text/javascript"> var duoshuoQuery = {short_name:"jensenwang"}; (function() { var ds = document.createElement('script'); ds.type = 'text/javascript';ds.async = true; ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js'; ds.charset = 'UTF-8'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds); })(); </script> <!-- 多说公共JS代码 end --> <div class="footer"> <div class="container"> <p class="footer-entry">All content is licensed under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA</a></p> <p class="footer-entry">Buit with <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> and <a href="https://github.com/P233/3-Jekyll" target="_blank">3-Jekyll theme</a> • Hosted on <a href="https://pages.github.com/" target="_blank">Github</a></p> </div> </div> </main> <button id="menu"> <span id="menu-icons"></span> </button> <script src="/assets/js/jquery-2.1.3.min.js"></script> <script src="/assets/js/jquery.pjax.js"></script> <script src="/assets/js/nprogress.js"></script> <script src="/assets/js/main.js"></script> </body> </html>
