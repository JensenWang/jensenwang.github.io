<!DOCTYPE html> <html> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" /> <!--[if lte IE 9]><meta http-equiv="refresh" content="0;url=/ie.html"><![endif]--> <title>Java开发中常见的23种设计模式(二)</title> <meta name="description" content="之前讲了五种创建型模式，接下来是七种结构型模式：适配器模式、装饰模式、代理模式、外观模式、桥接模式、组合模式、享元模式。其中对象的适配器模式是各种模式的起源："> <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,400italic,600|Droid+Sans+Mono' rel='stylesheet' type='text/css'> <link rel="stylesheet" href="/css/main.css"> <link rel="canonical" href="http://jensenwang.github.io/2016/04/08/DesingPattern_2.html"> <link rel="alternate" type="application/rss+xml" title="JensenWang" href="http://jensenwang.github.io/feed.xml" /> <link rel="shortcut icon" type="image/x-icon" href="/assets/img/avatar.jpg" media="screen" /> <script src="/assets/js/prefixfree.js"></script> </head> <body> <aside id="sidebar"> <div id="sidebar-left"> <a id="sidebar-avatar" href="/"> <img id="sidebar-avatar-img" alt="" src="/assets/img/avatar.jpg"/> </a> <div id="sidebar-social"> <a href="/feed.xml" class="sidebar-social-icon feed"></a> <a href="mailto:blankinter@163.com" class="sidebar-social-icon email"></a> <a href="https://github.com/jensenwang" class="sidebar-social-icon github" target="_blank"></a> </div> <ul id="sidebar-tags"> <li class="sidebar-tag active" data-filter="all">全部文章</li> <li class="sidebar-tag" data-filter="Java">Java</li> </ul> </div> <div id="sidebar-right"> <div id="search-box"> <input id="search-input" type="text" placeholder="Search" /> </div> <nav id="toc"> <a class="toc-link" data-tags="Java" href="/2016/04/08/DesingPattern_2.html"> Java开发中常见的23种设计模式(二) </a> <a class="toc-link" data-tags="Java" href="/2016/03/23/DesingPattern_1.html"> Java开发中常见的23种设计模式(一) </a> <a class="toc-link" data-tags="Java" href="/2016/02/29/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html"> Java异常处理 </a> <a class="toc-link" data-tags="Java" href="/2016/01/24/Java%E5%9F%BA%E7%A1%80.html"> Java 基础 </a> </nav> </div> </aside> <main id="main"> <article class="post container"> <div class="post-meta"> <span class="post-meta-span date">2016 April 08</span> <span class="post-meta-span tag">Java</span> </div> <h1 class="post-title">Java开发中常见的23种设计模式(二)</h1> <p>之前讲了五种创建型模式，接下来是七种结构型模式：适配器模式、装饰模式、代理模式、外观模式、桥接模式、组合模式、享元模式。其中对象的适配器模式是各种模式的起源： <img src="http://i4.piimg.com/303c321827ebe9c9.png" alt="" /></p> <h2 id="section">适配器模式</h2> <p>适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配造成的类的兼容性问题。主要分为三类：类的适配器，对象的适配器，接口的适配器模式。</p> <p><strong>类的适配器：</strong> <img src="http://i4.piimg.com/a1851884e45be831.jpg" alt="" /> 核心思想就是：有一个Source类，拥有一个方法，待适配，目标接口是Targetable，通过Adapter类，将Source的功能扩展到Targetable里：</p> <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Source</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">method1</span><span class="o">(){</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"This is original method!"</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span></code></pre></figure> <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Targetable</span> <span class="o">{</span>
    <span class="c1">// 与原类中方法相同</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">method1</span><span class="o">();</span>
    <span class="c1">// 新类的方法</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">method2</span><span class="o">();</span>
<span class="o">}</span></code></pre></figure> <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Adapter</span> <span class="kd">extends</span> <span class="n">Source</span> <span class="kd">implements</span> <span class="n">Targetable</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">method2</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"This is targetable method!"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Adapter</span> <span class="kd">extends</span> <span class="n">Source</span> <span class="kd">implements</span> <span class="n">Targetable</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">method2</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"This is targetable method!"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure> <p>Adapter类继承Source类，实现Targetable接口，下面是测试类：</p> <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AdapterTest</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="n">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Targetable</span> <span class="n">target</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Adapter</span><span class="o">();</span>
        <span class="n">target</span><span class="o">.</span><span class="na">method1</span><span class="o">();</span>
        <span class="n">target</span><span class="o">.</span><span class="na">method2</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure> <p><strong>对象的适配器模式：</strong></p> <p>基本思路和类的适配器模式相同，只是将Adapter类作修改，这次不继承Source类，而是持有Source类的实例，已达到解决兼容性的问题。 <img src="http://i2.piimg.com/5ed11c50586c3225.png" alt="" /> 只需要修改Adapter类的源码即可：</p> <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Wrapper</span> <span class="kd">implements</span> <span class="n">Targetable</span><span class="o">{</span>
    <span class="kd">private</span> <span class="n">Source</span> <span class="n">source</span><span class="o">;</span>

    <span class="kd">public</span> <span class="n">Wrapper</span><span class="o">(</span><span class="n">Source</span> <span class="n">source</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">();</span>
        <span class="k">this</span><span class="o">.</span><span class="na">source</span> <span class="o">=</span> <span class="n">source</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">method1</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">source</span><span class="o">.</span><span class="na">method1</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">method2</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"This is targetable method!"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure> <p>测试类：</p> <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AdapterTest</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="n">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Source</span> <span class="n">source</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Source</span><span class="o">();</span>
        <span class="n">Targetable</span> <span class="n">target</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Wrapper</span><span class="o">(</span><span class="n">source</span><span class="o">);</span>
        <span class="n">target</span><span class="o">.</span><span class="na">method1</span><span class="o">();</span>
        <span class="n">target</span><span class="o">.</span><span class="na">method2</span><span class="o">();</span>
    <span class="o">}</span>

<span class="o">}</span></code></pre></figure> <p><strong>接口的适配器模式：</strong> 接口的适配器模式是这样的：有时我们写的一个接口中有多个抽象方法，当我们写该接口的实现类时，必须实现该接口的所有方法，这明显有时比较浪费，因为并不是所有的方法都是我们需要的，有时只需要某一些，此处为了解决这个问题，我们引入了接口的适配器模式，实现了所有的方法，而我们不和原接口打交道，只和该抽象类去的联系，所以我们写一个类，重写我们需要的方法就行。 <img src="http://i2.piimg.com/b343f6798ada7dd5.png" alt="" /></p> </article> <div class="post-share"> <div class="container"> <a href="https://twitter.com/share?url=http://jensenwang.github.io/2016/04/08/DesingPattern_2.html&text=Java开发中常见的23种设计模式(二)" target="_blank" class="post-share-icon twitter"></a> <a href="https://www.evernote.com/clip.action?url=http://jensenwang.github.io/2016/04/08/DesingPattern_2.html&title=Java开发中常见的23种设计模式(二)" target="_blank" class="post-share-icon evernote"></a> <a href="http://service.weibo.com/share/share.php?url=http://jensenwang.github.io/2016/04/08/DesingPattern_2.html&title=Java开发中常见的23种设计模式(二)" target="_blank" class="post-share-icon weibo"></a> </div> </div> <!-- 多说评论框 start --> <div style="width: 80% padding: 0 30px" class="ds-thread" data-thread-key=/2016/04/08/DesingPattern_2 data-title=Java开发中常见的23种设计模式(二) data-url=http://jensenwang.github.io//2016/04/08/DesingPattern_2.html></div> <!-- 多说评论框 end --> <!-- 多说公共JS代码 start (一个网页只需插入一次) --> <script type="text/javascript"> var duoshuoQuery = {short_name:"jensenwang"}; (function() { var ds = document.createElement('script'); ds.type = 'text/javascript';ds.async = true; ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js'; ds.charset = 'UTF-8'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds); })(); </script> <!-- 多说公共JS代码 end --> <div class="footer"> <div class="container"> <p class="footer-entry">All content is licensed under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA</a></p> <p class="footer-entry">Buit with <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> and <a href="https://github.com/P233/3-Jekyll" target="_blank">3-Jekyll theme</a> • Hosted on <a href="https://pages.github.com/" target="_blank">Github</a></p> </div> </div> </main> <button id="menu"> <span id="menu-icons"></span> </button> <script src="/assets/js/jquery-2.1.3.min.js"></script> <script src="/assets/js/jquery.pjax.js"></script> <script src="/assets/js/nprogress.js"></script> <script src="/assets/js/main.js"></script> </body> </html>
